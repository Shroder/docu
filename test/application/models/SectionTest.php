<?php

require_once dirname(__FILE__) . '/../../../application/models/Section.php';

/**
 * Test class for Section.
 * Generated by PHPUnit on 2011-11-30 at 13:15:23.
 */
class SectionTest extends PHPUnit_Framework_TestCase {

    /**
     * @var Section
     */
    protected $object;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp() {

    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown() {
        
    }
    
    /**
     * @covers $section->__construct
     * Tests the ability to create new sections.
     */
    public function testCanCreateSection() {
        $section = new Section("/foo", "Some Section");
        $this->assertEquals("/foo", $section->getPath());
        $this->assertEquals("Some Section", $section->getTitle());
    }
    
    /**
     * @covers $section->__construct
     * Tests the prevention of orphan section creation
     */
    public function testCannotCreateOrphanSection() {
        try {
            $section = new Section("/bad/path", "Bad Section");
            $section = $this->getMock("Section", array('getParent'), array("/bad/path", "Bad Section")); 
            $section->expects($this->any())
                    ->method('getParent')
                    ->will($this->returnValue(false));
        } catch (Exception $e) {
            $this->assertEquals("Invalid parent set", $e->getMessage());
            return;
        }
        $this->fail("Exception expected");
    }
    
    /*
     * @covers @section->_construct
     * Tests the prevention of bad paths
     */
    public function testCanDetectInvalidPaths() {
        try {
            $section = new Section("?bad?section");
        } catch (Exception $e) {
            $this->assertEquals("Invalid path set", $e->getMessage());
            return;
        }
        
    }

    /**
     * @covers $section->__construct
     * Tests the ability to retrieve sections
     */
    public function testCanRetrieveSection() {
        // Get root
        $section = new Section("/");
        $this->assertNotEmpty($section->site);
        $this->assertEquals(1, $section->_id);
        
        // Get subsection by path
        $section = new Section("/topics");
        $this->assertNotEmpty($this->site, $section);
        $this->assertEquals(2, $section->_id);
        
        // Get subsection by title
        $section = new Section("topics");
        $this->assertNotEmpty($this->site, $section);
        $this->assertEquals(3, $section->_id);
    }    
    
    /**
     * @covers $section->getPath()
     * @todo Implement testGetPath().
     */
    public function testGetPath() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
                'This test has not been implemented yet.'
        );
    }

    /**
     * @covers $section->getSegmentedPath()
     * @todo Implement testGetSegmentedPath().
     */
    public function testGetSegmentedPath() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
                'This test has not been implemented yet.'
        );
    }

    /**
     * @covers $section->getParent()
     * Expected return: Section
     * @todo Implement testGetParent().
     */
    public function testGetParent() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
                'This test has not been implemented yet.'
        );
    }

    /**
     * @covers $section->getContentList()
     * @todo Implement testGetContentList().
     */
    public function testGetContentList() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
                'This test has not been implemented yet.'
        );
    }

    /**
     * @covers $section->getContent()
     * @todo Implement testGetContent().
     */
    public function testGetContent() {
        // Remove the following lines when you implement this test.
        $this->markTestIncomplete(
                'This test has not been implemented yet.'
        );
    }

    /**
     * @covers $section->setMainTemplate()
     * Tests the ability to set main template
     */
    public function testCanSetMainTemplate1() {
        $section = new Section("bare_section");
        $this->assertEmpty($section->getMainTemplate());

        $section->setMainTemplate('listing/template.tpl');
        $this->assertEquals("listing/template", $section->getMainTemplate());
        //$this->assertNotEmpty($section->templates['main']->_id);       
        //$section->Commit();
        //Assert records exist
        
    }
    
    /**
     * @covers $section->setDetailTemplate()
     * Tests the ability to set detail template
     */
    public function testCanSetDetailTemplate() {
        $section = new Section("bare_section");
        $section->setDetailTemplate("Article", "detail/template.tpl");
        $this->assertEquals("detail/template", $section->getDetailTemplate("Article"));
        //$this->assertNotEmpty($section->getDetailTemplate("Article")->_id);
    }
    
    public function testTemplateMustBeString() {
        $section = new Section("bare_section");
        try {
            $section->setDetailTemplate("Article", new StdClass());
        } catch (Exception $e)
        {
            $this->assert("Template must be string", $e->getMessage());
            return;
        }
        $this->fail("Non-string template input should not be accepted");
    }

    /**
     * @covers $section->getMainTemplate()
     * Tests the ability to set detail template
     */
    public function testCanGetMainTemplate() {
        $section = new Section("complete_section");
        $template = $section->getMainTemplate("Article");
        $this->assertNotEmpty($template);
        $this->assertType("Template", $template);
    }

    /**
     * @covers $section->setDetailTemplate()
     * Tests the ability to get detail template
     */
    public function testCanGetDetailTemplate() {
        $section = new Section("complete_section");
        $template = $section->getDetailTemplate("Article");
        $this->assertNotEmpty($template);
        $this->assertType("Template", $template);
    }
    
    /**
     * @covers $section->getAllTemplates()
     * Tests ability to retrieve ALL templates
     * associated to section.
     * Don't see a reason to use this on the frontend.
     */
    public function testCanGetAllTemplates() {
        $section = new Section("complete_section");
        $templates = $section->getAllTemplates();
        $this->assertNotEmpty($templates);
        $this->assertInternalType("Array", $templates);
        $this->assertType("Template", $templates[0]);
    }
    
    /**
     * @covers $section->getAllDetailTemplates()
     * Tests ability to retrieve all detail templates.
     * Todo: Assertion that main template doesn't show up
     */
    public function testCanGetAllDetailTemplates() {
        $section = new Section("complete_section");
        $templates = $section->getAllDetailTemplates();
        $this->assertNotEmpty($templates);
        $this->assertInternalType("Array", $templates);
        $this->assertType("Template", $templates[0]);
    }    
    
    /**
     * @covers $section->getModules()
     */
    public function testGetModules() {
        $section = new Section("complete_section");
        $this->assertObjectHasAttribute("modules", $section);
        $modules = $section->getModules("left");
        $this->assertEquals(3, $modules); 
        
        $this->assertType("Module", $modules[0]);
    }

    /**
     * @covers $section->getModule()
     */
    public function testGetModule() {
        $section = new Section("complete_section");
        $module = $section->getModule(1245); // By _id
        $this->assertNotEmpty($module);
        $this->assertType("Module", $module);
        
        $module = $section->getModule("left", 0); // column, Order
        $this->assertNotEmpty($module);
        $this->assertType("Module", $module);
    }
    
    public function testGetNonExistentModule() {
        $section = new Section("complete_section");
        $module = $section->getModule(999999); // By _id
        $this->assertEquals(null, $module);
        
        $module = $section->getModule("badcolumn", 0); // column, Order
        $this->assertEquals(null, $module);
    }

    /**
     * @covers $section->addModule()
     * Tests ability to add a module
     */
    public function testCanSetModule() {
        $section = new Section("bare_section");
        $section->setModule("left", new Module("Test"));
        $section->setModule("left", new Module("Test 2"), 0);
        $this->assertEquals(2, count($section->getModules("left")));
        $module = $section->getModule(0);
        $this->assertEquals("Test", $module->title);
    }
    
    public function testCannotSetNonModuleToModules() {
        $section = new Section("bare_section");
        try {
            $section->setModule("left", new Template("Test"));
        } catch (Exception $e) {
            $this->assertEquals("Module must be type Module", $e->getMessage());
            return;
        }
        $this->fail("Should not allow non-modules to be added");
        
    }
}